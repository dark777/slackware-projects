1) Configurando o banco de dados MariaDB.

1-1ª) Passo - Daremos permissao de execução a rc.mysql:

bash-4.4$ su -c "chmod 755 /etc/rc.d/rc.mysqld"


1-2ª) Passo - Se o mysql estiver executando vamos dar um stop:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld stop"


1-3ª) Passo - Criando o banco de dados e o usuário mysql:

bash-4.4$ su -c "mysql_install_db --user=mysql"


1-4ª) Passo - Agora Inicie o MariaDB:

bash-4.4$ su -c "mysqld_safe --user=mysql&"


1-5ª) Passo - Vamos configurar os parametros de segurança do MariaDB:
bash-4.4$ su -c "mysql_secure_installation"

Enter current password for root (enter for none): [ENTER]

OK, successfully used password, moving on... 

Set root password? [Y/n] [Y] Y

New password: (Digite aqui aquela que será a sua senha)
Re-enter new password: (Redigite a senha)
Password updated successfully!

Remove anonymous users? [Y/n] Y

Disallow root login remotely? [Y/n] Y

Remove test database and access to it? [Y/n] Y

Reload privilege tables now? [Y/n] Y


1-6ª) Passo - Vamos criar a pasta mysql em /var/log:

bash-4.4$ su -c "mkdir -p /var/log/mysql"


1-7ª) Passo - Diga quem é o dono de /var/log/mysql recursivamente:

bash-4.4$ su -c "chown -R mysql.mysql /var/log/mysql"


1-8ª) Passo - Como o mysql está executando vamos dar um stop:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld stop"


1-9ª) Passo - Depois de dar stop vamos matar o processo:

bash-4.4$ su -c "killall mysqld"


1-10ª) Passo - Iniciando o server mysqld:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld start"


##################################################################################################

2) Alterando a senha de root do MySQL no Slackware 14.1. Caso você não tenha criado a senha de
root no passo 1-5 ou perdido sua senha de root use os passos abaixo para criar ou recriar a senha.

2-1ª) Passo - Se o mysql está executando vamos dar um stop:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld stop"


2-2ª) Passo - Depois de dar stop abra outro terminal e,
vamos matar o processo:

bash-4.4$ su -c "killall mysqld"


2-3ª) Passo - Depois faça:

bash-4.4$ su -c "mysqld_safe --skip-grant-tables"


2-4ª) Passo - Volte ao terminal do passo 2-1ª, e acesse o banco:

bash-4.4$ su -c "mysql --user=root mysql"


2-5ª) Passo - Estando no console do banco,
digite o comando para atualizar a senha:

MariaDB [mysql]>  update user set password=password('aqui_a_nova_senha') where user='root';
MariaDB [mysql]>  flush privileges;
MariaDB [mysql]>  exit;


2-5.1ª) Passo OPCIONAL - Redefinir as permissões

 mysql> grant all privileges on *.* to 'root'@'%';  
 mysql> grant all privileges on *.* to 'root'@'localhost';  
 mysql> grant all privileges on *.* to 'root@localhost';  

2-5.2ª) Finalizando:

 mysql> SHOW GRANTS FOR 'root'@'%';  
 mysql> FLUSH PRIVILEGES;  


2-6ª) Passo - Reinicie o mysqld:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld restart"


2-7ª) Passo - Agora Pra acessar o MySQL digite:

bash-4.4$ su -c "mysql -p"
ou
bash-4.4$ su -c "mysql -u root -p"
ou
bash-4.4$ su -c "mysql -h localhost -u root -p"

##################################################################################################

3) Fazendo importação e exportacao de arquivos TXT's,
correspondentes a uma tabela para MariaDB(Mysql).


Os dados do arquivo TXT serão os dados abaixo:
01; Boi Preto; 2000-02-29
02; Sol Nascente; 2009-10-01
03; Parque Belo; 2007-03-15
04; Pedra Bonita; 2001-08-25
05; Nossa Senhora; 2011-06-22


3-1ª) Passo - Vamos criar o arquivo contendo os dados no diretório do seu usuário comum:

Digite a seguinte linha abaixo abrindo aspas,
com o su e pressione ENTER e depois que apareceu >
copie e cole o conteúdo acima que será importado para o banco de dados teste
depois de copiado pressione ENTER e digite EOF, e o arquivo cadastros.txt será criado.


bash-4.4$ cat >~/cadastros.txt<<EOF
>01; Boi Preto; 2000-02-29
>02; Sol Nascente; 2009-10-01
>03; Parque Belo; 2007-03-15
>04; Pedra Bonita; 2001-08-25
>05; Nossa Senhora; 2011-06-22
EOF


3-2ª) Passo - Vamos logar no MariaDB:

bash-4.4$ su -c "mysql -h localhost -u root -p"
Senha: <digite a senha do admin root>.
pressione ENTER

Enter password: <digite a senha do seu MariaDB(Mysql)>
pressione ENTER


3-2.1ª) Passo - Caso você tenha o sudo ativado em seu Slackware faça:

bash-4.4$ sudo mysql -h localhost -u root -p
Senha: <digite a senha do admin root>.
pressione ENTER

Enter password: <digite a senha do seu MariaDB(Mysql)>
pressione ENTER


# Aparecerá a seguinte linha de comando abaixo:

MariaDB [(none)]>


3-3ª) Passo -  Logado no MariaDB vamos criar o banco  teste:

MariaDB [(none)]> create database teste;                                                                                                                       
Query OK, 1 row affected (0.00 sec)


3-3.1ª) Passo - Listando o banco de dados criado:

MariaDB [(none)]> show databases;
+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| teste              |
+--------------------+
4 rows in set (0.00 sec)


3-4ª) Passo - Entrando no banco teste para criarmos a tabela:

MariaDB [(none)]> use teste;


3-4.1ª) Passo - Feito isso aparecerá o seguinte terminal abaixo:

MariaDB [teste]>


3-5ª) Passo - Criaremos a tabela cadastros:

MariaDB [teste]> create table cadastros(
    -> `id_faz` int unique not null primary key,                                 
    -> `nome_faz` varchar(25) unique not null,   
    -> `data_compra` date not null
    -> )engine=InnoDB default charset=latin1;
Query OK, 0 rows affected (0.00 sec)


3-5.1ª) Passo - Listando a tabela criada:

MariaDB [teste]> show tables;
+-----------------+
| Tables_in_teste |
+-----------------+
| cadastros       |
+-----------------+
1 row in set (0.00 sec)


3-6ª) Passo - Importando o arquivo cadastros.txt para o banco teste:

MariaDB [teste]> load data local infile "cadastros.txt" into table cadastros fields terminated by ';';
Query OK, 5 rows affected (0.01 sec)                 
Records: 5  Deleted: 0  Skipped: 0  Warnings: 0

Onde terminated by é o separador dos dados dentro do arquivo.


3-7ª) Passo - Listaremos os dados inseridos na tabela:

MariaDB [teste]> select *from cadastros;
+--------+----------------+-------------+
| id_faz | nome_faz       | data_compra |
+--------+----------------+-------------+
|    1   |  Boi Preto     |  2000-02-29 |
|    2   |  Sol Nascente  |  2009-10-01 |
|    3   |  Parque Belo   |  2007-03-15 |
|    4   |  Pedra Bonita  |  2001-08-25 |
|    5   |  Nossa Senhora |  2011-06-22 |
+--------+----------------+-------------+
5 rows in set (0.00 sec)


3-7.1ª) Passo - Deletando a linha que contem o id_faz=2 da tabela cadastros:

MariaDB [teste]> delete from cadastros where id_faz=2;
Query OK, 1 row affected (0.00 sec)                                                                            
                                                                                                               
MariaDB [teste]> select *from fazendas;                                                                        
+--------+---------------+-------------+                                                                       
| id_faz | nome_faz      | data_compra |                                                                       
+--------+---------------+-------------+                                                                  
|      1 |  Boi Preto    | 2000-02-29  |                                                                 
|      3 |  Parque Belo  | 2007-03-15  |                                                                    
|      4 |  Pedra Bonita | 2001-08-25  |                                                                       
|      5 |  Medeiros     | 2011-06-22  |                                                                       
+--------+---------------+-------------+                                                                       
4 rows in set (0.00 sec)


3-7.2ª) Passo - Reinserindo o dado excluido:

MariaDB [teste]> insert into cadastros(id_faz,nome_faz,data_compra)values("2", "Sol Nascente", "2009-10-01");
Query OK, 1 row affected (0.00 sec)


3-7.3ª) Passo - Listando os dados da tabela:

MariaDB [teste]> select *from cadastros;
+--------+---------------+-------------+
| id_faz | nome_faz      | data_compra |
+--------+---------------+-------------+
|      1 |  Boi Preto    | 2000-02-29  |
|      2 | Sol Nascente  | 2009-10-01  |
|      3 |  Parque Belo  | 2007-03-15  |
|      4 |  Pedra Bonita | 2001-08-25  |
|      5 |  Medeiros     | 2011-06-22  |
+--------+---------------+-------------+


3-8ª) Passo - Fazendo um update do campo nome_faz na tabela cadastros:

MariaDB [teste]> update cadastros set nome_faz="Agua Bonita" where id_faz=5;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0


3-8.1ª) Passo - Listando os dados da tabela:

MariaDB [teste]> select *from cadastros;
+--------+---------------+-------------+
| id_faz | nome_faz      | data_compra |
+--------+---------------+-------------+
|      1 |  Boi Preto    | 2000-02-29  |
|      2 | Sol Nascente  | 2009-10-01  |
|      3 |  Parque Belo  | 2007-03-15  |
|      4 |  Pedra Bonita | 2001-08-25  |
|      5 | Agua Bonita   | 2011-06-22  |
+--------+---------------+-------------+
6 rows in set (0.00 sec)


Note que no id_faz=5, o campo nome_faz que continha:

nome_faz="Medeiros"

foi atualizado para:

nome_faz="Agua Bonita"

##################################################################################################

4ª) Passo - Agora vamos realizar os mesmos passos acima mas com auto_increment.
Primeiro vamos exportar os dados importados em nossa tabela cadastros,
para um novo arquivo que será salvo em  /tmp chamado exportacao.txt:


4-1ª) Passo - Exportando os dados da tabela cadastros para a pasta /tmp/ no arquivo exportacao.txt:

MariaDB [teste]> select id_faz, nome_faz, data_compra into outfile "/tmp/exportacao.txt" \
fields terminated by ';'  from cadastros;
Query OK, 6 rows affected (0.00 sec)

Este comando acima exporta campos específicos de uma tabela,
a priori poderíamos deixar o campo id_faz de lado, mas como estamos aprendendo,
a exportar os dados de uma tabela estamos exportando todos os campos.

Ou você também pode usar um destes comando abaixo:

MariaDB [teste]> select * from cadastros into outfile "/tmp/exportacao.txt" \
fields terminated by ';';
Query OK, 5 rows affected (0.00 sec)


MariaDB [teste]> select * into outfile "/tmp/exportacao.txt" \
fields terminated by ';'  from cadastros;
Query OK, 5 rows affected (0.00 sec)


Com estes três comandos acima todos os  campos da tabela são exportados,
para /tmp/exportacao.txt, nossos dados exportados
ficará no formato abaixo sem o separador ";" no final:

bash-4.4$ cat /tmp/exportacao.txt
1;Boi Preto;2000-02-29
2;Sol Nascente;2009-10-01
3;Parque Belo;2007-03-15
4;Pedra Bonita;2001-08-25
5;Nossa Senhora;2011-06-22


# Você também pode usar este comando abaixo:

MariaDB [teste]> select * into outfile "/tmp/exportacao.txt" fields terminated by \
';' lines terminated by ';\n' from cadastros;

Query OK, 5 rows affected (0.01 sec)

Com este comando acima nossos dados exportados para /tmp/exportacao.txt
ficara no formato abaixo note os separadores ";" no final:

bash-4.4$ cat /tmp/exportacao.txt
1;Boi Preto;2000-02-29;
2;Sol Nascente;2009-10-01;
3;Parque Belo;2007-03-15;
4;Pedra Bonita;2001-08-25;
5;Nossa Senhora;2011-06-22;

Com estes quatro comandos acima, não importa como nossos dados exportados,
para /tmp/exportacao.txt, ficarão formatados você só não pode usar o comando abaixo,
pois a forma como ele exporta os dados dificulta nosso serviço,
aumentando a complexidade mas como queremos 
manter as coisas o mais simples não o use para esta finalidade:

MariaDB [teste]> select * into outfile "/tmp/exportacao.txt" fields terminated by ';' \
enclosed by '"' lines terminated by '' from cadastros;

# Este comando acima salvaria os dados neste formato abaixo:

bash-4.4$ cat /tmp/exportacao.txt
"1";"Boi Preto";"2000-02-29";"2";"Sol Nascente";"2009-10-01";"3";"Parque Belo";"2007-03-15"; \
"4";"Pedras Bonitas";"2017-12-12";"5";"Medeiros";"2011-06-22";

# Mas caso você tenha usado este comando acima crie um arquivo chamado format.sed com a
seguinte linha de comando abaixo:

bash-4.4$ cat >format.sed<<EOF
sed 's/;/\n/g'|sed 'N;N;s/\n//'|sed 'N;s/\n//'|sed '/^$/d'|sed 's/"/;/g;s/;;/;/g'
EOF

# Depois que você criou o arquivo format.sed vamos dar permissão de execução:

bash-4.4$ chmod a+x format.sed

# E faça:

bash-4.4$ cat /tmp/exportacao.txt | ./format.sed > /tmp/formatados.txt && cat /tmp/formatados.txt
;1;Boi Preto;2000-02-29;
;2;Sol Nascente;2009-10-01;
;3;Parque Belo;2007-03-15;
;4;Pedras Bonitas;2017-12-12;
;5;Medeiros;2011-06-22;


4-2ª) Passo - Vamos editar o arquivo /tmp/formatados.txt removendo todos os id's,
deixando somente os nomes e datas com o ponto e virgula antes dos nomes,
pois ai esta o pulo do gato, para termos sucesso na nossa importação
em uma tabela com auto_increment. Então digite o comando abaixo
para formatar o arquivo:

bash-4.4$ su -c "sed -i 's/^;.//' /tmp/formatados.txt && cat /tmp/formatados.txt"
;Boi Preto;2000-02-29;
;Sol Nascente;2009-10-01;
;Parque Belo;2007-03-15;
;Pedras Bonitas;2017-12-12;
;Medeiros;2011-06-22;


Ou você também pode usar um destes comando abaixo,
este comando é mais útil pois geralmente uma tabela exportada,
contém centenas ou milhares de registros:

MariaDB [teste]> select  nome_faz, data_compra into outfile "/tmp/exportacao.txt" \
fields terminated by ';' lines terminated by ';\n'  from cadastros;
Query OK, 5 rows affected (0.00 sec)


MariaDB [teste]> select nome_faz, data_compra from cadastros into outfile "/tmp/exportacao.txt" \
fields terminated by ';' lines terminated by ';\n';
Query OK, 5 rows affected (0.00 sec)


Com estes dois comandos acima nossos dados exportados para /tmp/exportacao.txt
ficou sem os id's que se encontra no campo id_faz deixado de lado,
ficando no formato abaixo note os separadores ";" no final e a ausencia dos id's:

bash-4.4$ cat /tmp/exportacao.txt
Boi Preto;2000-02-29;
Sol Nascente;2009-10-01;
Parque Belo;2007-03-15;
Pedra Bonita;2001-08-25;
Nossa Senhora;2011-06-22;


4-3ª) Passo - Precisamos adicionar os separadores que estariam após os id's,
que foi deixado de lado, precisamos colocar os separadores ";",
antes dos nomes, pois sem estes separadores todo nosso trabalho,
vai por água abaixo quando importar o arquivo para a tabela devolta.
Então digite o comando abaixo para formatar o arquivo:

bash-4.4$ su -c "sed -i '/^/ s//;/g;' /tmp/exportacao.txt"
Senha: <digite a senha do admin root>.
pressione ENTER


O comando sed acima adicionará os separadores ";" antes dos nomes,
entao nosso arquivo em  /tmp/exportacao.txt  ficara assim como este abaixo,
note os separadores ";" no inicio da linha:

bash-4.4$ cat /tmp/exportacao.txt
;Boi Preto;2000-02-29;
;Sol Nascente;2009-10-01;
;Parque Belo;2007-03-15;
;Pedra Bonita;2001-08-25;
;Nossa Senhora;2011-06-22;


4-3.1ª) Passo - Vamos deletar nossa tabela cadastros,
para recriar novamente mas com auto_increment.

MariaDB [teste]> drop table cadastros;
Query OK, 0 rows affected (0.04 sec)


4-3.2ª) Passo - Recriando a tabela cadastros com auto_increment:

MariaDB [teste]>  create table cadastros(
    -> `id_faz` int auto_increment primary key,
    -> `nome_faz` varchar(25) unique not null,
    -> `data_compra` date not null
    -> )engine=InnoDB default charset=latin1;;
Query OK, 0 rows affected (0.01 sec)


Ou se preferir pode apenas alterar o campo id_faz.
para que o campo seja auto_increment,
digite o comando abaixo.

MariaDB [teste]>  alter table cadastros change `id_faz` `id_faz` int auto_increment;                  
Query OK, 5 rows affected (0.04 sec)               
Records: 5  Duplicates: 0  Warnings: 0


4-3.4ª) Passo - Precisamos fazer um truncate na nossa tabela cadastros,
simplesmente por que criamos os campos nome_faz como unique, 
caso contrário, poderíamos fazer apenas a importação,
novamente pois ficaria com id's auto_increment de 6 a 10. 
Mas os nomes e datas ficariam redundantes, isso se você esta fazendo,
uma reimportação, dos dados que foram exportados da mesma tabela,
onde o campo nome seja unique, ou até mesmo de outra tabela que possua, 
um nome gravado no campo, e seja o mesmo que ja esta gravado na tabela atual,
caso contrário tudo se sucederá perfeitamente.


MariaDB [teste]> truncate table cadastros;
Query OK, 0 rows affected (0.01 sec)


MariaDB [teste]> select * from cadastros;
Empty set (0.00 sec)


4-3.5ª) Passo - Importando novamente o arquivo /tmp/exportacao.txt,
ja formatado na sessao 3 passo 10.1ª, para o banco teste.


MariaDB [teste]> load data local infile "/tmp/exportacao.txt" \
into table cadastros fields terminated by ';';

Query OK, 5 rows affected, 5 warnings (0.81 sec)     
Records: 5  Deleted: 0  Skipped: 0  Warnings: 5


MariaDB [teste]> select *from cadastros;
+--------+-----------------+-------------+
| id_faz | nome_faz        | data_compra |
+--------+-----------------+-------------+
|    1   |  Boi Preto      | 2000-02-29  |
|    2   |  Sol Nascente   | 2009-10-01  |
|    3   |  Parque Belo    | 2007-03-15  |
|    4   |  Pedra Bonita   | 2001-08-25  |
|    5   |  Nossa Senhora  | 2011-06-22  |
+--------+-----------------+-------------+
5 rows in set (0.00 sec)

##################################################################################################

Liberar 3306 do MySQL no Slackware:

2ª) Passo - No arquivo /etc/rc.d/rc.mysqld comente a linha: 

SKIP="--skip-networking"

Deixando-a assim:

#SKIP="--skip-networking"


1ª) Passo - Digite uma das duas linhas abaixo no terminal: 

bash-4.4$ su -c "sed '/SKIP/ s/^/#/g;' /etc/rc.d/rc.mysqld"
ou
bash-4.4$ su -c "sed '32s/^/#/g;' /etc/rc.d/rc.mysqld"


2ª) Passo - Reinicie o mysqld:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld restart"

##################################################################################################

Restauração de backup:

bash-4.4$ mysql -u <usuario> -p --databases <dbname> < banco.sql


Backup do banco com os dados data hora e log:

data=$(date +%a%H%M%S%d%m%y)
sqlname="$data.sql"
logname="$data.log"

bash-4.4$ mysqldump --databases <dbname> --routines --single-transaction \
--result-file="$sqlname" -v -h localhost -u root -p -P 3306  2>> $logname


Backup de uma tabela especifica:

bash-4.4$ mysqldump -u root -p --databases <dbname> <tabela> > cadastros.sql


Backup de duas tabelas especifica chamada tabela1 e tabela2:

bash-4.4$ mysqldump -u root -p --databases <dbname> tabela1 tabela2 > tab1_tab2.sql


Backup de todas as tabelas com exceção de uma:

bash-4.4$ mysqldump -u root -p --databases <dbname> \
--ignore-table=<dbname>.<nometabela> > backup.sql


Backup de todas as tabelas com exceção de duas ou mais:

bash-4.4$ mysqldump -u root -p --databases <dbname> \
--ignore-table=<dbname>.{tabela1,tabela2,tabela3} > backup.sql

ou

bash-4.4$ mysqldump -u root -p --databases <dbname> --ignore-table=<dbname>.tabela1 \
--ignore-table=<dbname>.tabela2 > backup.sql


Backup de todas as bases de dados:

bash-4.4$ mysqldump --all-databases > ~/mysql_all.sql -v -h localhost -u root -p -P 3306

##################################################################################################

Fazendo backup das bases de dados do MySQL

Uma das grandes dúvidas de qualquer administrador iniciante é como fazer backup das bases de dados
do MySQL, já que os dados são gravados e acessados através do servidor MySQL e não diretamente
através de arquivos, como no caso dos arquivos referentes aos sites, salvos na pasta "/var/www",
por exemplo.

As bases de dados do MySQL são salvas por padrão dentro da pasta "/var/lib/mysql". Ao criar a base
de dados "phpbb", por exemplo, será criada a pasta "/var/lib/mysql/phpbb", contendo um conjunto
de arquivos, referentes, às tabelas criadas.

A forma mais simples de fazer backup das bases de dados do MySQL é simplesmente salvar o conteúdo
da pasta "/var/lib/mysql", criando um arquivo .tar.gz ou mesmo copiando os arquivos diretamente
para outra partição. O maior problema é que as bases de dados são alteradas continuamente durante
a operação do banco de dados, o que leva a cópias inconsistentes. Se alguns dos arquivos dentro da
pasta com a base mudam no meio da cópia, o backup conterá uma mistura de dados novos e antigos,
uma receita para o desastre.

A forma mais segura é parar o serviço do MySQL antes de fazer o backup, garantindo assim que nada
será alterado durante a cópia, como no exemplo abaixo:

bash-4.4$ su -c "/etc/rc.d/rc.mysqld stop"

A segunda opção é fazer um backup online, sem parar o servidor. O utilitário mais simples 
(e provavelmente o mais usado) para isso é o mysqldump, que acompanha o pacote principal do MySQL.

Para salvar todas as bases de dados do servidor no arquivo "backup.sql", criado no diretório atual,
por exemplo, o comando seria:

bash-4.4$ mysqldump -u root -p -x -e -A > backup.sql

O "-u root -p" especifica o usuário que será usado para acessar o banco de dados.
No exemplo estou fazendo um backup completo, por isso estou usando diretamente o root.
A opção "-x" trava as bases de dados no momento em que cada uma é copiada,
evitando qualquer problema de inconsistência, enquanto a "-e" é uma opção de otimização,
que permite ao mysqldump combinar argumentos INSERT dentro das tabelas, o que torna
tanto o backup quanto a restauração mais rápidos. Finalizando, a opção "-A"
especifica um backup completo, de todas as bases de dados.

Se o comando parasse por aí, o mysqldump simplesmente escreveria todo o conteúdo das bases
de dados na própria janela do terminal, resultando em uma longa exibição de informações,
sem muita utilidade. Como queremos que a saída seja salva em um arquivo, usamos o ">", 
que redireciona a saída para o arquivo especificado.

O arquivo "backup.sql" gerado é basicamente um arquivo de texto gigante contendo declarações
de todas as informações armazenadas. Você pode reduzir o tamanho do arquivo para um quarto
(ou menos) do tamanho original compactando o arquivo, o que pode ser feito adicionando a
opção "| gzip" antes do ">" no comando, como em:

bash-4.4$ mysqldump -u root -p -x -e -A | gzip > backup.sql.gz

Note que nesse exemplo adicionei também o ".gz" no nome do arquivo, indicando que se trata de
um arquivo compactado. Para usá-lo posteriormente, você precisaria apenas descompactar o arquivo,
usando o comando "gunzip", como em:

bash-4.4$ gunzip backup.sql.gz

O maior problema com estes dois comandos é que você precisa digitar a senha depois de rodar
o comando, o que dificulta seu uso em scripts de backup automático. É possível eliminar a
necessidade de digitar a senha especificando-a diretamente no comando, depois do "-p"
(sem espaços), como em:

bash-4.4$ mysqldump -u root -p12345 -x -e -A | gzip > backup.sql.gz

Note que ao incluir senhas em arquivos, é extremamente importante restringir as permissões, de forma que
apenas o root (ou o usuário em questão) tenha permissão para lê-lo. Qualquer outro usuário do servidor que
tenha acesso de leitura no arquivo, poderá ler a senha e acessar o servidor MySQL.

Continuando, os comandos acima permitem fazer um backup completo de todas as bases do servidor, que
poderia ser usado para restaurar os dados em uma instalação limpa do MySQL. É possível também fazer
backups localizados, contendo apenas uma base de dados específica.

Nesse caso, em vez de usar a opção "-A", você usaria a opção "-B", seguida pela base de dados a ser salva,
como em:

bash-4.4$ mysqldump -u root -p -x -e -B phpbb > phpbb.sql

Na hora de restaurar o backup, deixamos de usar o mysqldump e passamos a utilizar o cliente mysql, que se
encarrega de ler os comandos e os dados adicionados nos arquivos e usá-los para povoar as bases de dados.
O comando ficaria então:

bash-4.4$ mysql -u root -p --databases phpbb < phpbb.sql

Você pode também especificar a senha diretamente no comando, assim como no caso do mysqldump, como em:

bash-4.4$ mysql -u root -p12345 --databases phpbb < phpbb.sql

Se você tentar restaurar o backup sobre uma base de dados contendo dados, provavelmente receberá uma
mensagem de erro logo no início do processo, avisando que uma das tabelas já existe, como em:

ERROR 1050 at line 19: Table 'wp_comments' already exists

A solução no caso é remover a base de dados antiga usando o cliente MySQL e criar outra em branco para
então fazer a restauração, como em:

bash-4.4$ su -c "mysql -u root -p"

mysql> DROP DATABASE phpbb;
Query OK, 0 rows affected (0.00 sec)

mysql> CREATE DATABASE phpbb;
Query OK, 1 row affected (0.00 sec)

mysql> exit

bash-4.4$ mysql -u root -p --databases phpbb < phpbb.sql

Outra opção seria adicionar a opção "--add-drop-table" ao gerar o backup com o mysqldump.
Ela faz com que ele inclua instruções para que as bases sejam excluídas e recriadas
automaticamente durante a restauração, evitando que você precise fazê-lo manualmente.
O comando ficaria então:

bash-4.4$ mysqldump --add-drop-table -u root -p -x -e -B phpbb > phpbb.sql

O comando para restaurar continua o mesmo, com a diferença de que você não precisa
mais dar o DROP DATABASE; CREATE DATABASE antes de fazer a restauração.

Esta opção pode ser adicionada também ao comando para fazer o backup completo das
bases de dados, facilitando assim sua restauração:

bash-4.4$ mysqldump --add-drop-table -u root -p -x -e -A > backup.sql

O backup poderia ser então restaurado diretamente usando o comando abaixo,
sem que você precisasse remover as bases e tabelas manualmente antes de
iniciar a recuperação:

bash-4.4$ mysql -u root -p < backup.sql

O backup usando o mysqldump e a restauração usando o mysql são preferíveis à cópia manual
dos arquivos da pasta "/var/lib/mysql", pois evita problemas de incompatibilidade ao migrar
os dados para versões diferentes do MySQL. Além disso, a facilidade de fazer o backup sem
precisar parar o servidor é uma grande vantagem em um ambiente de produção.

##################################################################################################

Resolvendo problemas de caracteres acentuados no MySQL

Antes de importar os dados para a sua base MySQL, defina um collation padrão. No Brasil o
Latin1 é o mais utilizado, então o CHARSET (codificação de caracteres) padrão na
Maxrevenda é o Latin1 e o COLLATE (collation) padrão é o latin1_general_ci. Scripts
externos podem utilizar UTF8 e geralmente é por causa da diferença de codificação entre
Latin1 e UTF8 que ocorrem erros de acentuação.
A seguir estão alguns exemplos para definir um collation padrão para a sua base de dados:

MariaDB [teste]> ALTER DATABASE `sua_base` CHARSET = Latin1 COLLATE = latin1_swedish_ci;

ou

MariaDB [teste]> ALTER DATABASE `sua_base` CHARSET = UTF8 COLLATE = utf8_general_ci;

CHARSET e COLLATE são coisas distintas, no MySQL, cada CHARSET possui COLLATEs,
cada um com sua particularidade. O intuito deste Wiki não é explicar as características de
cada um deles, pois pode ser visto da documentação do MySQL, mas daremos um pequeno
descritivo entre latin1_general_ci, latin1_general_cs e latin1_swedish_ci.

latin1_general_ci: Não há distinção entre letras maiúsculas e minúsculas. Buscando
por “teste”, registros como “Teste” ou “TESTE” serão retornados.

latin1_general_cs: Distingue letras maiúsculas e minúsculas. Buscando por “teste”
somente retornará “teste”. Opções como “Teste” e “TESTE” não serão retornadas.

latin1_swedish_ci: Não distingue letras minúsculas e maiúsculas e nem caracteres
acentuados e com cedilha, ou seja, o registro que contém a palavra “Intuição”
será retornado quando houver uma procura pela palavra “intúicao”.

Quando você estiver exportando os dados da sua base de dados de origem, certifique-se de
estar especificando a codificação corretamente. No phpMyAdmin há um menu DropDown próximo
às opções de compactação ‘nenhum’, ‘zip’, ‘gzip’ e ‘bzip’ que normalmente está selecionada
a opção ‘utf-8’. Mantenha este se sua base estiver com este CHARSET, do contrário, 
especifique ‘iso-8859-1’ caso ela esteja com o CHARSET Latin1.Faça o mesmo durante a
importação. Ao enviar o arquivo, o menu DropDown estará como ‘utf-8’,
se o CHARSET da base for ‘Latin1’ escolha o ‘iso-8859-1’.

##################################################################################################

Sources:
http://www.hardware.com.br/dicas/mysql.html
https://www.vivaolinux.com.br/dica/MySQL-Backup-automatico-de-banco-de-dados-com-data
https://pt.stackoverflow.com/questions/37297/backup-de-todas-as-tabelas-com-exceção-de-uma
http://analiselogin.blogspot.com.br/2012/10/mysqldump-escolhendo-as-tabelas-dentro.html
http://www.andersonmedeiros.com/importar-arquivos-txt-para-postgresql/
http://aquicode.blogspot.com.br/2014/07/excluindo-tabelas-do-mysqldump.html
http://analiselogin.blogspot.com.br/2012/10/mysqldump-escolhendo-as-tabelas-dentro.html
http://www.novotopico.com/aprendendo-a-mecher-no-phpmyadmin-t6363.html
http://blog.ffelix.eti.br/exportar-dados-de-tabelas-mysql-para-txt-ou-csv/
https://www.rlsystem.com.br/outros/noticia/select-insert-delete-update-mysql/
https://llagerlof.wordpress.com/2009/12/12/como-criar-um-banco-de-dados-no-mysql/
https://www.scriptbrasil.com.br/forum/topic/139195-resolvido-importar-um-arquivo-txt-para-o-meu-bd/
http://www.bosontreinamentos.com.br/mysql/mysql-delete-e-truncate-table-excluir-registros-de-uma-tabela-16/
https://imasters.com.br/artigo/6446/mysql/utilizacao-de-datas-no-mysql?trace=1519021197&source=single
https://imasters.com.br/artigo/321/php/gravando-resultado-de-um-sql-em-um-arquivo-txt/?trace=1519021197&source=single